<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TRAPX v0 - Urban Systems Prototype</title>

<style>

/* ================================
   GLOBAL RESET (OLD SCHOOL)
================================ */

html, body {
    margin: 0;
    padding: 0;
    background: #050514;
    color: #00ffff;
    font-family: monospace;
    overflow: hidden;
}

/* ================================
   HUD
================================ */

#hud {
    position: fixed;
    top: 8px;
    left: 8px;
    padding: 8px;
    background: rgba(0,0,0,0.6);
    border: 1px solid #00ffff;
    font-size: 12px;
}

/* ================================
   GRID
================================ */

#world {
    position: absolute;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
}

.cell {
    position: absolute;
    box-sizing: border-box;
    border: 1px solid rgba(0,255,255,0.15);
    transition: background 0.6s;
}

/* states */

.cell.neutral { background: #050505; }
.cell.player  { background: #ff00cc; }
.cell.enemy   { background: #00ff66; }
.cell.corrupt { background: #400014; }

/* ================================
   ENTITIES
================================ */

.entity {
    position: absolute;
    width: 6px;
    height: 6px;
    background: white;
    border-radius: 2px;
    pointer-events: none;
}

.entity.citizen { background:#ffffff; }
.entity.runner  { background:#00ffff; }
.entity.masked  { background:#ff0000; }

/* ================================
   DAY NIGHT
================================ */

#overlay {
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    pointer-events:none;
    background: rgba(0,0,0,0);
    transition: background 2s;
}

</style>
</head>

<body>

<div id="hud">
TRAPX v0<br>
Tick: <span id="tick">0</span><br>
Time: <span id="time">Day</span><br>
Citizens: <span id="citizens">0</span>
</div>

<div id="world"></div>
<div id="overlay"></div>

<script>

/* ================================
   CONSTANTS
================================ */

const GRID_SIZE = 20;
const CELL_SIZE = 40;
const SIM_INTERVAL = 800;

const STATE_NEUTRAL = 0;
const STATE_PLAYER  = 1;
const STATE_ENEMY   = 2;
const STATE_CORRUPT = 3;

/* ================================
   DATA STRUCTURES
================================ */

var grid = [];
var entities = [];

var sim_tick = 0;
var day_time = 0;

/* ================================
   SIM HOOKS (EXPOSED)
================================ */

var sim_weights = {
    convert_threshold: 3,
    corruption_spread: 4,
    growth_chance: 0.05
};

window.TRAPX_SIM_SET_WEIGHT = function(name,value){
    sim_weights[name] = value;
};

window.TRAPX_SIM_SPAWN_ENTITY = function(type){
    spawn_entity(type);
};

/* ================================
   INIT
================================ */

var world = document.getElementById("world");

function init_grid(){
    for(let y=0;y<GRID_SIZE;y++){
        grid[y]=[];
        for(let x=0;x<GRID_SIZE;x++){

            let cell = {
                state: STATE_NEUTRAL,
                population: Math.random()*120,
                el: document.createElement("div")
            };

            cell.el.className="cell neutral";
            cell.el.style.width = CELL_SIZE+"px";
            cell.el.style.height = CELL_SIZE+"px";
            cell.el.style.left = (x*CELL_SIZE)+"px";
            cell.el.style.top  = (y*CELL_SIZE)+"px";

            world.appendChild(cell.el);

            grid[y][x]=cell;
        }
    }

    // seed some pressure

    grid[5][5].state = STATE_PLAYER;
    grid[14][12].state = STATE_ENEMY;
    grid[10][3].state = STATE_CORRUPT;

    refresh_grid();
}

function spawn_entity(type){
    let e = {
        type:type,
        x: Math.random()*GRID_SIZE*CELL_SIZE,
        y: Math.random()*GRID_SIZE*CELL_SIZE,
        vx: (Math.random()-0.5)*1.5,
        vy: (Math.random()-0.5)*1.5,
        el: document.createElement("div")
    };

    e.el.className="entity "+type;
    world.appendChild(e.el);
    entities.push(e);
}

/* ================================
   GRID LOGIC
================================ */

function get_neighbors(x,y){
    let list=[];
    for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
            if(dx==0 && dy==0) continue;
            let nx=x+dx, ny=y+dy;
            if(nx>=0 && ny>=0 && nx<GRID_SIZE && ny<GRID_SIZE){
                list.push(grid[ny][nx]);
            }
        }
    }
    return list;
}

function sim_update_grid(){

    let changes=[];

    for(let y=0;y<GRID_SIZE;y++){
        for(let x=0;x<GRID_SIZE;x++){

            let cell = grid[y][x];
            let neighbors = get_neighbors(x,y);

            let counts=[0,0,0,0];

            neighbors.forEach(n=>{
                counts[n.state]++;
            });

            if(cell.state===STATE_NEUTRAL){
                if(counts[STATE_PLAYER]>=sim_weights.convert_threshold)
                    changes.push([cell,STATE_PLAYER]);

                if(counts[STATE_ENEMY]>=sim_weights.convert_threshold)
                    changes.push([cell,STATE_ENEMY]);

                if(counts[STATE_CORRUPT]>=sim_weights.corruption_spread)
                    changes.push([cell,STATE_CORRUPT]);
            }

            if(Math.random()<sim_weights.growth_chance){
                cell.population+=10;
            }

            if(cell.population>220){
                cell.population=100;
            }
        }
    }

    changes.forEach(c=>{
        c[0].state=c[1];
    });

    refresh_grid();
}

function refresh_grid(){
    for(let y=0;y<GRID_SIZE;y++){
        for(let x=0;x<GRID_SIZE;x++){
            let c=grid[y][x];
            c.el.className="cell "+
                (c.state==STATE_NEUTRAL?"neutral":
                c.state==STATE_PLAYER?"player":
                c.state==STATE_ENEMY?"enemy":"corrupt");

            let intensity = Math.min(1,c.population/200);
            c.el.style.opacity = 0.4+intensity*0.6;
        }
    }
}

/* ================================
   ENTITY LOGIC
================================ */

function update_entities(){

    entities.forEach(e=>{

        e.x+=e.vx;
        e.y+=e.vy;

        if(e.x<0||e.x>GRID_SIZE*CELL_SIZE) e.vx*=-1;
        if(e.y<0||e.y>GRID_SIZE*CELL_SIZE) e.vy*=-1;

        e.el.style.left=e.x+"px";
        e.el.style.top =e.y+"px";
    });
}

/* ================================
   DAY / NIGHT
================================ */

function update_time(){

    day_time++;

    let overlay=document.getElementById("overlay");
    let time_label=document.getElementById("time");

    if(day_time%400<200){
        overlay.style.background="rgba(0,0,0,0)";
        time_label.innerText="Day";
    } else {
        overlay.style.background="rgba(0,0,0,0.35)";
        time_label.innerText="Night";
    }
}

/* ================================
   MAIN LOOP
================================ */

function sim_tick_step(){

    sim_tick++;
    document.getElementById("tick").innerText=sim_tick;

    sim_update_grid();
    update_time();
}

function frame_loop(){
    update_entities();
    requestAnimationFrame(frame_loop);
}

/* ================================
   BOOT
================================ */

init_grid();

// seed citizens

for(let i=0;i<25;i++) spawn_entity("citizen");
for(let i=0;i<8;i++) spawn_entity("masked");
for(let i=0;i<5;i++) spawn_entity("runner");

document.getElementById("citizens").innerText=entities.length;

setInterval(sim_tick_step,SIM_INTERVAL);
frame_loop();

</script>

</body>
</html>
